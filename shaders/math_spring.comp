#version 450
layout(local_size_x = 10, local_size_y = 10, local_size_z = 1) in;

struct Particle {
    vec4 pos;
    vec4 vel;
    vec4 uv;
    vec4 normal;
};

// SSBOs
layout(set = 0, binding = 0, std430) readonly buffer ParticleIn {
    Particle vin[];
};

layout(set = 0, binding = 1, std430) writeonly buffer ParticleOut {
    Particle vout[];
};

// UBO (std140 권장)
layout(set = 0, binding = 2, std140) uniform UBOCompute {
    float deltaT;
    float particleMass;
    float springStiffness;
    float damping;
    float restDistH;
    float restDistV;
    float restDistD;
    float sphereRadius;
    vec4  spherePos;
    vec4  gravity;
    ivec2 particleCount;
} params;

// Push constant
layout(push_constant) uniform PC {
    uint calculateNormals;
} pc;

vec3 springForce(vec3 p0, vec3 p1, float restDist)
{
    vec3 d = p0 - p1;
    float L = length(d);
    if (L < 1e-5) return vec3(0.0);
    return (d / L) * params.springStiffness * (L - restDist);
}

void main()
{
    uvec3 id = gl_GlobalInvocationID;
    uint idx = id.y * uint(params.particleCount.x) + id.x;

    if (id.x >= uint(params.particleCount.x) ||
        id.y >= uint(params.particleCount.y)) return;

    vec3 force = params.gravity.xyz * params.particleMass;

    vec3 pos = vin[idx].pos.xyz;
    vec3 vel = vin[idx].vel.xyz;

    // 이웃 스프링
    if (id.x > 0)
        force += springForce(vin[idx-1].pos.xyz, pos, params.restDistH);
    if (id.x + 1 < uint(params.particleCount.x))
        force += springForce(vin[idx+1].pos.xyz, pos, params.restDistH);
    if (id.y + 1 < uint(params.particleCount.y))
        force += springForce(vin[idx + uint(params.particleCount.x)].pos.xyz, pos, params.restDistV);
    if (id.y > 0)
        force += springForce(vin[idx - uint(params.particleCount.x)].pos.xyz, pos, params.restDistV);

    if (id.x > 0 && id.y + 1 < uint(params.particleCount.y))
        force += springForce(vin[idx + uint(params.particleCount.x) - 1].pos.xyz, pos, params.restDistD);
    if (id.x > 0 && id.y > 0)
        force += springForce(vin[idx - uint(params.particleCount.x) - 1].pos.xyz, pos, params.restDistD);
    if (id.x + 1 < uint(params.particleCount.x) && id.y + 1 < uint(params.particleCount.y))
        force += springForce(vin[idx + uint(params.particleCount.x) + 1].pos.xyz, pos, params.restDistD);
    if (id.x + 1 < uint(params.particleCount.x) && id.y > 0)
        force += springForce(vin[idx - uint(params.particleCount.x) + 1].pos.xyz, pos, params.restDistD);

    force += (-params.damping * vel);

    // 적분
    vec3 a = force / params.particleMass;
    vec3 newPos = pos + vel * params.deltaT + 0.5 * a * params.deltaT * params.deltaT;
    vec3 newVel = vel + a * params.deltaT;

    // 구 충돌 (간단)
    vec3 sDist = newPos - params.spherePos.xyz;
    if (length(sDist) < params.sphereRadius + 0.01) {
        newPos = params.spherePos.xyz + normalize(sDist) * (params.sphereRadius + 0.01);
        newVel = vec3(0.0);
    }

    vout[idx].pos = vec4(newPos, 1.0);
    vout[idx].vel = vec4(newVel, 0.0);

    if (pc.calculateNormals == 1u) {
        vec3 normal = vec3(0);
        vec3 a1,b1,c1;
        if (id.y > 0u) {
            if (id.x > 0u) {
                a1 = vin[idx - 1].pos.xyz - pos;
                b1 = vin[idx - uint(params.particleCount.x) - 1].pos.xyz - pos;
                c1 = vin[idx - uint(params.particleCount.x)].pos.xyz - pos;
                normal += cross(a1,b1) + cross(b1,c1);
            }
            if (id.x + 1u < uint(params.particleCount.x)) {
                a1 = vin[idx - uint(params.particleCount.x)].pos.xyz - pos;
                b1 = vin[idx - uint(params.particleCount.x) + 1].pos.xyz - pos;
                c1 = vin[idx + 1].pos.xyz - pos;
                normal += cross(a1,b1) + cross(b1,c1);
            }
        }
        if (id.y + 1u < uint(params.particleCount.y)) {
            if (id.x > 0u) {
                a1 = vin[idx + uint(params.particleCount.x)].pos.xyz - pos;
                b1 = vin[idx + uint(params.particleCount.x) - 1].pos.xyz - pos;
                c1 = vin[idx - 1].pos.xyz - pos;
                normal += cross(a1,b1) + cross(b1,c1);
            }
            if (id.x + 1u < uint(params.particleCount.x)) {
                a1 = vin[idx + 1].pos.xyz - pos;
                b1 = vin[idx + uint(params.particleCount.x) + 1].pos.xyz - pos;
                c1 = vin[idx + uint(params.particleCount.x)].pos.xyz - pos;
                normal += cross(a1,b1) + cross(b1,c1);
            }
        }
        vout[idx].normal = vec4(normalize(normal), 0.0);
    }
}
